<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <meta name="viewport" content="width=device-width, initial-scale=1 maximum-scale=1; minimum-scale=1; user-scalable=no;"> <meta content="System Programming Note" name="description"> <meta name="keywords" content="UNIX,School,Note,blog"> <meta name="author" content="GabrielWang"> <meta name="baseurl" content=""> <title> Gabriel Wang|System Programming </title> <!-- favicon --> <link rel="shortcut icon" href="/static/assets/img/favicon.ico"> <!-- Main CSS --> <link href="/static/assets/app-20210315.min.css" rel="stylesheet"> <link href="/static/css/custom.css" rel="stylesheet"> <!-- Main Scripts --> <script src="/static/assets/app-20210315.min.js"></script> <script src="/static/assets/blog-20210315.min.js"></script> <!-- Google AdSense --> <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script> <script> (adsbygoogle = window.adsbygoogle || []).push({ google_ad_client: "ca-pub-6196184620210315", enable_page_level_ads: true }); </script> </head> <body id="page-top" class="landing-page"> <div class="search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right: 0px; opacity: 0.95; background-color: #111111; z-index: 9999; display: none;"> <input type="text" class="form-control search-content" id="search-content" style="position: fixed; top: 60px" placeholder="Search Blog"> <div style="position: fixed; top: 16px; right: 16px; z-index: 9999;"> <img src="/static/assets/img/search/cb-close.png" id="close-btn"/> </div> </div> <div style="position: fixed; right: 16px; bottom: 20px; z-index: 9999;"> <img src="/static/assets/img/search/cb-search.png" id="search-btn" title="Double click Ctrl"/> </div> <div class="navbar-wrapper"> <nav class="navbar navbar-default navbar-fixed-top" role="navigation"> <div class="container"> <div class="navbar-header page-scroll"> <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Gabriel Wang</a> </div> <div id="navbar" class="navbar-collapse collapse"> <ul class="nav navbar-nav navbar-right"> <li><a class="page-scroll" href="blog/"></a></li> <li> <a class="page-scroll" href="/blog/">Blog</a></li> <li> <a class="page-scroll" href="/work/">Work</a></li> <li> <a class="page-scroll" href="/life/">Life</a></li> <li> <a class="page-scroll" href="/school/">School</a></li> </ul> </div> </div> </nav> </div> <div class="wrapper wrapper-content animated fadeInRight article"> <div class="row"> <div class="col-lg-10 col-lg-offset-1"> <div class="ibox"> <div class="ibox-content"> <div class="pull-right"> <a class="btn btn-white btn-xs" href="/school">School</a> </div> <div class="text-center article-title"> <span class="text-muted"><i class="fa fa-clock-o"></i> 21 May 2017</span> <h1> System Programming </h1> </div> <h1 id="system-programming-final-review">System Programming Final Review</h1> <h2 id="summary">Summary:</h2> <p>This write up will summarize and categorize important knowledge about system programming from the text book <em>Advanced Unix Programming 2nd Edition</em> and the notes from the class CS450 offered by Emory Computer Science Department, taught by Professor Ken Mandelberg, who constantly sighed during the lectures. Note this is for my own study and usage.</p> <h2 id="final-exam-range">Final Exam Range:</h2> <ul> <li>Ch1. 1-1.4,1.7</li> <li>Ch2. ALL</li> <li>CH3. 3.9.1 only in 3.9, and everything else</li> <li>Ch5. Thru 5.13</li> <li>Ch6. 6.1-6.4 (easy on 6.3)</li> <li>Ch7. 7.1-7.2, 7.4, 7.5.1, 7.5.2, 7.8, 7.9, 7.12, 7.13.1, 7.13.2</li> <li>Ch9. 9.1 - 9.1.6, 9.1.9, 9.1.10, 9.4, 9.6, 9.7.1, 9.7.2</li> </ul> <h2 id="content">Content:</h2> <ul> <li><a href="#c-and-unix">C and UNIX</a></li> <li><a href="#file-io">File I/O</a></li> <li><a href="#process-and-threads">Process and Threads</a></li> <li><a href="#interprocess-communication">Interprocess Comunication</a></li> </ul> <h2 id="codes">Codes:</h2> <ul> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW1">Goldbach test with Sieve Method</a></li> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW2">Archive program to do similar <code class="language-plaintext highlighter-rouge">ar</code> as system call</a></li> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW3">Uniqify and sort words from <code class="language-plaintext highlighter-rouge">stdin</code></a></li> <li><a href="https://github.com/gabrielwry/System-Programming/tree/master/HW4">Interprocess communication programs to compute perfect numbers</a></li> </ul> <h3 id="-c-and-unix"><span name="c-and-unix"> C and Unix</span></h3> <ul> <li>UNIX versions and standards: <ul> <li>UNIX was first developed as a research project in AT&amp;T Bell Lab</li> <li>Licenses of UNIX make their own modification. <strong>BSD</strong>, developed by Berkeley University supports <strong>sockets</strong> and <strong>virtual memory.</strong></li> <li>UNIX world divides to <strong>BSD</strong> side and <strong>System V side</strong>.</li> <li><strong>POSIX</strong> is a standard for UNIX system call and commands from IEEE.</li> <li>If an application conforms the <strong>standard</strong> and the <strong>language</strong> (<code class="language-plaintext highlighter-rouge">C, C++</code>) it is written in, the application’s source code is portable and can be compiled and run with no changes.</li> <li>Three principal strains of UNIX: <ul> <li>Closed commercial systems;</li> <li>BSD-based open source systems;</li> <li>Linux;</li> </ul> </li> </ul> </li> <li>System Calls <ul> <li>C and C++ Bindings: <ul> <li>A system call execute some special codes that transfers control from user to kernel and back, and hence it is <strong>expensive</strong></li> <li>Every system call is defined inside the <strong>header</strong> file, which can have conflicts due the implementation of the OS version, so sometimes a header file needs to be adjusted to work properly.</li> <li>Other languages also have standard facilities to support some POSIX facilities.</li> <li>Several tips for system call usages: <ul> <li>include header (废话);</li> <li>do error handling, maybe use <code class="language-plaintext highlighter-rouge">perror</code> really convenient;</li> <li><code class="language-plaintext highlighter-rouge">cast</code> is not very safe, it will suppress compiler warning if the types don’t match;</li> <li>check if call is thread safe;</li> <li>write standardized, so your program is portable;</li> </ul> </li> <li>Read the man page for function syntax and synopses.</li> </ul> </li> <li>Error Handling : <ul> <li>always check for error, most likely the call will return <code class="language-plaintext highlighter-rouge">-1</code> for error, and it will set the <code class="language-plaintext highlighter-rouge">errno</code>;</li> <li>There are system calls’s errors depends on changing <code class="language-plaintext highlighter-rouge">errno</code></li> <li>There is a <code class="language-plaintext highlighter-rouge">strerror()</code> call inside <code class="language-plaintext highlighter-rouge">&lt;error.h&gt;</code> that will translate the <code class="language-plaintext highlighter-rouge">errno</code> to understandable string.</li> <li>error macro is a gadget of codes that handle error checking for us, like <code class="language-plaintext highlighter-rouge">EC_CLEANUP_BGN</code> and <code class="language-plaintext highlighter-rouge">EC_CLEANUP_END</code></li> </ul> </li> </ul> </li> <li>Date and Times <ul> <li>Calendar time: used to log information about access, modification or status change times of a file. <ul> <li>Four types: , <ol> <li>arithmetic type <em>time_t</em> seconds since epoch, midnight , Jan 1st, 1970, always implemented as a <em>long 32-bit signed int</em>;</li> <li>struct type <em>timeval</em> time in seconds and millisec;</li> <li>struct type <em>tm</em>, breaks down to year, moth, day, hour, minute, sec</li> <li>string, like <em>Tue Jul 23 09:44:17 2002</em>;</li> </ol> </li> </ul> </li> <li>Execution time: used for tracking process execution. <ul> <li>Main types: <ul> <li>long type <em>clock_t</em>, time interval in units of <strong>CLOCKS_PER_SEC</strong></li> <li>struct type <em>timeval</em> holds an interval in seconds and microseconds</li> <li>struct type <em>timespec</em> holds interval in seconds and nanoseconds.</li> </ul> </li> </ul> </li> </ul> </li> </ul> <h3 id="file-io"><span name="file-io">File I/O</span></h3> <ul> <li> <p>File System:</p> <ul> <li>The block I/O system is accessed via a block special file, or block device that interfaces directly with the disk; <ul> <li>Disk can be dived to different volume, partition, or file system.</li> <li>Buffer cache can be performed on block Disk Device but not Raw Disk Device; dir, files, and i-nodes are not supported for either device.</li> </ul> </li> <li><code class="language-plaintext highlighter-rouge">statvfs() and fstatvfs()</code>: get file system information by path or by fd</li> <li>Mounting and unmounting file system: connecting to a disk device to the hierarchy tree started with root is called mounting, and disconnecting is called unmounting. <ul> <li>need device name and the intended directory to mount a file system, original content of the directory is now hided, will reappear when the device is unmounted</li> </ul> </li> <li>Hard link and Symbolic link: <ul> <li>hard link: an entry in a directory with a name and an i-number <ul> <li>create: can get a hard link when any types of file is created (including dir), and can get additional hard link to nondirectories with <code class="language-plaintext highlighter-rouge">link()</code> with oldpath and newpath, the two pathes are equivalent in anyway. The second new link must not be existed already, or otherwise need to unlink first.</li> <li>rename: use <code class="language-plaintext highlighter-rouge">mv</code> command, but won’t deal with link to another file system <ul> <li><code class="language-plaintext highlighter-rouge">rename()</code> system call: if new path exists, remove it with unlink or rmdir, link oldpath with new path even if the old path is a dir, remove the oldpath with unlink or rmdir</li> <li>Note that, new path and old path have to be either both dir or both files, if new path is dir, it has to be empty, you need write permission in new path’s parent, if rename fails, everything left unchanged</li> </ul> </li> </ul> </li> <li>symbolic link: symbolic links put path of file to be linked to in the data part of an actual file, no read or write but use system calls, symbolic link will recursively point to next link until something that is not a symbolic link is reached. <ul> <li>create: <code class="language-plaintext highlighter-rouge">symlink()</code> system call to make symbolic link, works like <code class="language-plaintext highlighter-rouge">link()</code>, but make a hard link to a symbolic link file that contain the string given by new path</li> <li>read: <code class="language-plaintext highlighter-rouge">readlink()</code></li> </ul> </li> </ul> </li> <li>Accessing and Displaying File Metadata: <ul> <li><code class="language-plaintext highlighter-rouge">stat() lstat() fstat()</code>: <code class="language-plaintext highlighter-rouge">stat</code> get file info by path, <code class="language-plaintext highlighter-rouge">lstat</code> get file info by path without following symbolic link, <code class="language-plaintext highlighter-rouge">fstat</code> get file info by file descriptor; <code class="language-plaintext highlighter-rouge">lstat</code> will display the metadata file of the symbolic link, if reached one.</li> </ul> </li> <li>Directory: UNIX implemented directory as a regular file, except a special bit is set in i-node and kernel does not permit writing on it. <ul> <li>Read: <code class="language-plaintext highlighter-rouge">opendir()</code> return dir pointer followed by the path <code class="language-plaintext highlighter-rouge">closedir()</code> close the dir pointed by the dirp pointer; <code class="language-plaintext highlighter-rouge">readdir()</code> read the dir pointed by the pointer returned from <code class="language-plaintext highlighter-rouge">opendir()</code> to the structure <code class="language-plaintext highlighter-rouge">dirent</code> which has i-number and name. <code class="language-plaintext highlighter-rouge">rewinddir()</code> can read it again without <code class="language-plaintext highlighter-rouge">close</code> and <code class="language-plaintext highlighter-rouge">reopen</code> it. Use <code class="language-plaintext highlighter-rouge">readdir_r()</code> to supply a memory to read the info into and supports multi threads.</li> <li><code class="language-plaintext highlighter-rouge">chdir() fchdir()</code> system call behind <code class="language-plaintext highlighter-rouge">cd</code> command, change directory by path or by file descriptor.</li> <li><code class="language-plaintext highlighter-rouge">mkdir() rmdir()</code> <ul> <li><code class="language-plaintext highlighter-rouge">mkdir()</code> automatically creates the . and .. dir</li> <li><code class="language-plaintext highlighter-rouge">rmdir()</code> has to remove non-empty dir, or multiple unlink are needed first.</li> </ul> </li> </ul> </li> <li>Changin I-Node: <ul> <li><code class="language-plaintext highlighter-rouge">chmod() fchmod()</code>: can change a file’s S_ISUID, S_ISGID, S_ISVTX and permission</li> <li><code class="language-plaintext highlighter-rouge">chown() fchown() lchown()</code>: change owner and group of a file by path or by fd, of regular file or symbolic link file.</li> <li><code class="language-plaintext highlighter-rouge">utime()</code> set file access time with struct <code class="language-plaintext highlighter-rouge">utimbuf</code></li> </ul> </li> </ul> </li> <li> <p>File types:</p> <ul> <li> <p>Ordinary File: segment of bytes</p> <ul> <li>The structure of a disk:</li> </ul> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	 |   Boot Block  |    
	 ===============
	 |   Super Block |  &lt;- Stores parameters of size
	 ===============
	 |   I-nodes     | &lt;- Meta data for a file (length, permission, group owner, time stamp, type, block list
	 ===============
	 |               |
	 ===============
	 |       DATA    |
    
</code></pre></div> </div> <ul> <li>Directories: has an i-node itself, using a 2-column to keep name -&gt; i-node <ul> <li>Relative path name starts with the current dir, absolute path starts with the root dir (usually i-node 2, stored when kernel is first constructed)</li> <li></li> </ul> </li> </ul> </li> </ul> </li> <li> <p>File Descriptor and Open File Description</p> <ul> <li>File Descriptor: <ul> <li>total: 1 - N, 0 is reserved for <code class="language-plaintext highlighter-rouge">stdin</code>, 1 is for <code class="language-plaintext highlighter-rouge">stdout</code>, 2 is for <code class="language-plaintext highlighter-rouge">stderr</code></li> <li>UNIX filter read from <code class="language-plaintext highlighter-rouge">STDIN_FILENO</code> and write to <code class="language-plaintext highlighter-rouge">STDOUT_FILENO</code> so the shell can use it in pipeline.</li> <li>can be used for any types of file</li> <li><code class="language-plaintext highlighter-rouge">open()</code> for files with regular file, special files, and FIFO, <code class="language-plaintext highlighter-rouge">pipe()</code> to open un-named pipes;</li> </ul> </li> <li>Open File Description: <ul> <li>file descriptor is just a pre-process table entry which will point to a file-table entry, Open File Description and then point to the data via <strong>i-node</strong></li> <li>multiple file descriptors can point to the same file description</li> <li>each <code class="language-plaintext highlighter-rouge">open</code> and <code class="language-plaintext highlighter-rouge">pipe</code> call creates a new <strong>file descriptor</strong> and a <strong>file description</strong></li> <li>duplication of file descriptor will point to the same file description. (<code class="language-plaintext highlighter-rouge">dup,dup2,fork</code> system calls)</li> </ul> </li> <li>Permission: <ul> <li>9 permissions in total: read,write,execute for owner, group and others</li> <li>Use bit operation <code class="language-plaintext highlighter-rouge">|</code> to set permission mask</li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">open</code> and <code class="language-plaintext highlighter-rouge">create</code> system call</p> <ul> <li><code class="language-plaintext highlighter-rouge">open</code> open an existing file, or create one (can only be regular file), and return a file descriptor which can be later used. <ul> <li>Existing File: specified by <code class="language-plaintext highlighter-rouge">path</code>, use flags <code class="language-plaintext highlighter-rouge">O_RDONLY O_WRONLY O_RDWR</code>, <code class="language-plaintext highlighter-rouge">PERM</code> arguments are always omitted for existing files; <ul> <li>file offsets is where <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> will occur and is placed at the first byte of the file</li> <li>files descriptor returned is the lowest number available.</li> </ul> </li> </ul> </li> <li>Creating File: need O_CREAT flag, <code class="language-plaintext highlighter-rouge">PERM</code> is used to set the file’s permission <ul> <li>O_TRUNC can make a fresh clean file with no data in it, if the process have right permission <ul> <li>new file will need write permission in parent directory, existing files only care about permission on the file itself</li> <li><code class="language-plaintext highlighter-rouge">create</code> system call to take care of the combination of flags</li> <li>Ownership: <ul> <li>owner set to effective user-ID of the process</li> <li>group is set to either groupID of the parent directory or the effective group-ID of the process</li> </ul> </li> <li>O_EXCL returns error if exists.</li> </ul> </li> <li>Using file as a lock: <ul> <li>For exclusive access to resource: try open a file with O_EXCL when trying to access resources, only one process will succeed, when that one process finished, it will unlink the file and other process can succeed on access theh resource.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">Unmask</code> and <code class="language-plaintext highlighter-rouge">unlink</code></p> <ul> <li><code class="language-plaintext highlighter-rouge">unmask()</code> is used to change the permission group 9-bit, it will return the old mask</li> <li><code class="language-plaintext highlighter-rouge">unlink()</code> reduces the link number in i-node by one, if the count reach 0, the file system will discard the file. <ul> <li>Note: if a process that has this file open is not closed yet, the actual file data will remain on the disk but the file name will be removed once the count reached 0.</li> <li>Any kind of file can be unlinked, but only superuser can unlink a dir, always use rmdir a directory.</li> </ul> </li> </ul> </li> <li> <p>Temporary Files: mkstemp guarantees to create a file with unique name, need to arrange <code class="language-plaintext highlighter-rouge">unlink()</code></p> </li> <li> <p>File offset and O_APPEND:</p> <ul> <li>A file offset is a position in regular file where next <code class="language-plaintext highlighter-rouge">read</code> or <code class="language-plaintext highlighter-rouge">write</code> will occur</li> <li>Independent offset each time a file is opened, as the file description is unique.</li> <li>Without the O_APPEND, the offset starts at zero, and unless specified, the <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> are sequential.</li> <li>O_APPEND will prevent from overwriting data, good for logging (setting offset of write to EOF automatically)</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">write()</code>:</p> <ul> <li>writes nbyte to the current position pointed by offset, and increment the offset by the number of bytes written;</li> <li><code class="language-plaintext highlighter-rouge">write()</code> doesn’t really write data to the disk, it actually first transfers data to a buffer and then return; If UNIX crashes: <ul> <li>real data won’t be written on disk</li> <li>process won’t be notified about the error, partial write won’t trigger the errno</li> <li>the order of the physical write can not be controlled</li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">read()</code>: read n-bytes from the current position specified by the offset, won’t be affected by the O_APPEND, partial read won’t trigger the errno.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">close()</code> only mark the file descriptor as reusable, when the last file descriptor pointed to a open file description is closed, the open file description closed as well ( the file description keeps the count of the file descriptors pointed to it, so it knows when the last one was deleted), then if the last file description pointed to an in memory i node is closed, the in memory i node is closed. Doesn’t have to <code class="language-plaintext highlighter-rouge">close</code> actually, it will automatically close once the process terminated.</p> </li> <li> <p>User Buffering: Not really much to say, BUFIO will accelerate the provess.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">lseek()</code>: set the file offset, return the result offset</p> <ul> <li>whence: SEEK_SET -&gt; set to pos, SEEK_CUR -&gt; set to current + pos (can be positive, 0, or negative), SEEK_END -&gt; set to file size + pos</li> <li>resulting offset must be non-negative</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">pread() pwrite()</code>: it is the <code class="language-plaintext highlighter-rouge">read</code> and <code class="language-plaintext highlighter-rouge">write</code> ignoring the offset, don use and don’t set .</p> <ul> <li>will solve the problem of another process changing the offset between <code class="language-plaintext highlighter-rouge">lseek()</code> and <code class="language-plaintext highlighter-rouge">read, write</code></li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">readv() writev()</code>: can write contagious data to the file in different places at once, need to set up the <code class="language-plaintext highlighter-rouge">*iov</code> to make it contain a pointer to data and the size of the data. Save some time by avoiding multiple system calls.</p> </li> <li> <p>Synchronized I/O:</p> <ul> <li>Synchronized vs. Synchronous: Normally UNIX is un-synchronized and synchronous <ul> <li>Synchronized means the <code class="language-plaintext highlighter-rouge">write()</code> doesn’t return until the actual data is written on the disk;</li> <li>Synchronous means the <code class="language-plaintext highlighter-rouge">read()</code> doesn’t return until data is available and <code class="language-plaintext highlighter-rouge">write()</code> has at least put the data in kernel buffer, and actually writes to disk if it is also Synchronized.</li> </ul> </li> <li>Buffer-flushing System Calls: <ul> <li><code class="language-plaintext highlighter-rouge">sync()</code> tell the kernel to schedule flushing all buffer written so far, but it returns once it is scheduled. Used when kernel is shut down or a portable device is unmounted.</li> <li><code class="language-plaintext highlighter-rouge">fsync()</code>flushes buffer specified by <code class="language-plaintext highlighter-rouge">fd</code> and didn’t return until buffer is indeed flushed, if the System is set to be synchronized.</li> <li><code class="language-plaintext highlighter-rouge">fdatasync()</code>is faster than <code class="language-plaintext highlighter-rouge">fsync()</code> as it only flushes the real data, not the controlling data like modification time.</li> <li>open flags for synchronization: <ul> <li>O_SYNC: an implicit <code class="language-plaintext highlighter-rouge">fsync()</code> for every write;</li> <li>O_DSYNC: an implicit <code class="language-plaintext highlighter-rouge">fdatasync()</code> for every write</li> <li>O_RSYNC: update the access time in a synchronized manner.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">truncate()</code> and <code class="language-plaintext highlighter-rouge">ftruncate()</code>: <code class="language-plaintext highlighter-rouge">truncate()</code> with path name, and <code class="language-plaintext highlighter-rouge">ftruncate()</code> with fd to shrink the file.</p> </li> </ul> <h3 id="process-and-threads"><span name="process-and-threads">Process and Threads</span></h3> <ul> <li> <p>Environment:</p> <ul> <li>when a UNIX program runs, it receives two groups of data, the arguments and the environment, which are both array of character pointer to NUL-terminated strings.</li> <li>global variable <code class="language-plaintext highlighter-rouge">environ</code> has the form name = value; can use <code class="language-plaintext highlighter-rouge">getenv()</code> to get the corresponding envrion; use <code class="language-plaintext highlighter-rouge">putenv()</code> <code class="language-plaintext highlighter-rouge">setenv()</code> and <code class="language-plaintext highlighter-rouge">unsetenv()</code> to adjust environment variables</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">exec()</code> system call:<code class="language-plaintext highlighter-rouge">exec()</code> system call reinitialized a process from a designated program, always used with <code class="language-plaintext highlighter-rouge">fork()</code></p> <ul> <li>Program, processes, and threads: <ul> <li>Program, collection of instruction and data that is kept in a regular file on disk, marked executable in i-node; contents obey rules established by the kernel; program into text-file -&gt; object file with machine-language translation; linker is used to bind object file with libraries</li> <li>Process, is created to run a program; contains three segments: instruction seg, user data seg, system data seg (include current dic, open file des, accumulated CPU time);</li> <li>Threads, are tracked by kernel: separate flow of control through instructions, start with one thread, unless execute special system call to create another;</li> <li>There is no functional relationship between processes initialized from the same program ( process can not detect shared instruction seg); strong functional replationship between threads in the same process</li> <li>Process has inheritance, threads are equal ( all threads have equal access to all data and resources, not copy)</li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">fork()</code> create a new process by copying the system-data segment from the old process, child receives a 0 on success return and parent receives the process-ID of the child. Then the child usually does an exec and the parent either waits or do something else.</p> <ul> <li>Several things that are not inherited by the child process: <ul> <li>pid (废话）</li> <li>if the parent is multiprocess, only the one calling fork() exists on child</li> <li>same file description but different file descriptor</li> <li>execution time</li> </ul> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">exit()</code>: same as returning a value from main and call <code class="language-plaintext highlighter-rouge">exit()</code> on that argument</p> <ul> <li>_exit and _Exit one is from UNIX, the other from standard C</li> <li><code class="language-plaintext highlighter-rouge">exit()</code> a higher level than <code class="language-plaintext highlighter-rouge">_exit</code> as it does some sort of clean up, call function registered atexit, and do a flush of I/O buffer.</li> <li>usually call <code class="language-plaintext highlighter-rouge">_exit</code> in a child process that hasn’t done an <code class="language-plaintext highlighter-rouge">exec</code></li> <li>upon termination: all open file descriptors are closed, all child processes now have a special system process as parent</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">wait(),waitpid(),waitid()</code>: waits for a child process</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">waitpid()</code>:</p> <ul> <li> <p>pid argument:</p> <ul> <li> <blockquote> <p>0: wait for the specific child process with pid</p> </blockquote> </li> <li> <p>-1: wait for any child process</p> </li> <li> <p>0: wait for any child process in the same process group as the calling process</p> </li> <li>&lt; -1: wait for any child process in the process group whose process-group id is -pid</li> </ul> </li> <li> <p>only direct child created by <code class="language-plaintext highlighter-rouge">fork()</code> can be waited for, normally a process should wait for every child it created, or the terminated child process may exist in system as zombie until parents terminated</p> </li> <li> <p>a child changes status is waitable, can cause at most one return from waitpid</p> </li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">wait()</code> is a short hand for <code class="language-plaintext highlighter-rouge">waitpid</code> with pid = -1</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">waitid()</code> get the status of a process back and keep it waitable</p> </li> </ul> </li> <li> <p>Setting User and Group IDs and Process IDs: Kernel keeps the saved id that were set by last <code class="language-plaintext highlighter-rouge">exec()</code>, no ordinary process can explicitly change real user ID or saved ID, except <code class="language-plaintext highlighter-rouge">exec</code> can change saved id; ordinary process can change effective ID to real or saved ID, superuser can change real and effective ID to any value, saved ID changes with the real ID if a superuser changes it.</p> <ul> <li>use <code class="language-plaintext highlighter-rouge">seteuid, setegid</code> superuser can also use <code class="language-plaintext highlighter-rouge">setuid, setgid</code></li> <li><code class="language-plaintext highlighter-rouge">getpid()</code> and <code class="language-plaintext highlighter-rouge">getppid()</code> can get process ID or process ID of parent.</li> </ul> </li> </ul> <h3 id="-interprocess-communication"><span name="interprocess-communication"> Interprocess Communication</span></h3> <ul> <li> <p>Pipe: unnamed Pipe</p> <ul> <li>create: <code class="language-plaintext highlighter-rouge">pipe</code> system call, returns an array of 2 file descriptor, representing a communication channel, writing to pfd[1] to put data in pipe, and read from pfd[0] to get it out; use <code class="language-plaintext highlighter-rouge">pipebuf</code> when multiple processes are writing to the same pipe, so that data written is atomic (if bytes smaller or equal to buf size);</li> <li>Pipe behavior: <ul> <li><code class="language-plaintext highlighter-rouge">write</code>: data written to a pipe is sequenced in order of arrival, and <code class="language-plaintext highlighter-rouge">write</code> will block if not enough room until enough data was removed by <code class="language-plaintext highlighter-rouge">read</code>. There is no partial write. If amount is larger than PIPE_BUF, partial write is possible.</li> <li><code class="language-plaintext highlighter-rouge">read</code> : data read from pipe is in order of arrival, and can not be reread or put back. <code class="language-plaintext highlighter-rouge">read</code> will block if there is no data for reading, or return 0 if all <code class="language-plaintext highlighter-rouge">write</code> ends are closed, byte count is the most byte can be read at once .</li> <li><code class="language-plaintext highlighter-rouge">close</code> : if frees up the file descriptor for reuse, and if all writing end are closed, reader will reach EOF. If all reading ends closed, <code class="language-plaintext highlighter-rouge">write</code> returns an error.</li> <li><code class="language-plaintext highlighter-rouge">fstat</code> and <code class="language-plaintext highlighter-rouge">lseek</code> are not useful</li> <li><code class="language-plaintext highlighter-rouge">dup</code> and <code class="language-plaintext highlighter-rouge">dup2</code> : duplicate a new file descriptor that points to the same file and shared the same file description, <code class="language-plaintext highlighter-rouge">dup2</code> can specify which fd to use, and will close it if necessary.</li> </ul> </li> <li>General Guidance: create a pipe -&gt; fork the reading child -&gt; close the writing end and do other preparation in child process -&gt; execute the child program in child process -&gt; close the reading end in parent process -&gt; if using a second child to write, create it and make preparation, if parent is writing, just write.</li> </ul> </li> <li> <p>FIFO or Named Pipe: FIFO combines regular files and pipes, it has name and can be opened by any process with the right permission, so unrelated process can communicate over a FIFO. Always opened for reading and waiting for a different process to open it for writing, once created, it follows the same pipe behavior, vice versa. O_NONBLOCK flag can be used read will succeed and write will fail if no reader is opened, this prevent putting data in the FIFO</p> <ul> <li>create: <code class="language-plaintext highlighter-rouge">mkfifo</code>: the PERM is used to set the new file permission, once it is created, it behaves like a pipe. Mostly useful to pass data between server and client.</li> <li>critique: single FIFO can not have multiple read ends, data has to be copied back and forth causing too many system calls;</li> </ul> </li> <li> <p>System V IPC: older set of semaphores, message queue and shared memory, newer is POSIX IPC</p> <ul> <li>These three objects are not files, but mechanism with unique naming. Principles: <ul> <li>exist only within a single machine, can not communicate through network</li> <li>life time is the same as kernel</li> <li>access through an integer key that is invariant for the whole life time , any process know this key can open the object</li> </ul> </li> <li>use system calls : (msg, sem, shm) + (get, ctl); also msgsnd, msgrcv and semop shmat, smdt.</li> <li><code class="language-plaintext highlighter-rouge">ftok</code>can generate keys from pathname, specified by the id parameter; two different paths in the same file system will generate different keys</li> <li>Ownership and Permission: use the struct <code class="language-plaintext highlighter-rouge">ipc_perm</code> for permission that specify owner and creator user and group ID</li> <li>utilities in command line: use ipcs for displaying info, ipcrm to remove specified object</li> </ul> </li> <li> <p>System V Message Queue:</p> <ul> <li> <p>System calls:</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">msgget</code>:IPC_CREAT and IPC_EXCL to set flags for creating or failing if exists. A key IPC_PRIVATE will guarantee a unique key</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">msgctl</code>: take the struct msqid_ds to control the existing queue (IPC_RMID to remove, IPC_STAT to get info IPC_SET to set id, mode and permission.</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">msgsnd</code> and <code class="language-plaintext highlighter-rouge">msgrcv</code>: with a struct <code class="language-plaintext highlighter-rouge">msg</code> that can be user-defined, and a type parameter:</p> <ul> <li> <p>= 0: receive the first message, regardless type</p> </li> <li> <blockquote> <p>0 : receive first message of specified type</p> </blockquote> </li> <li> <p>&lt; 0: get first message with type lower or equal the absolute value of type</p> </li> <li> <p>if don’t care, use 1 when send, and 0 when receive</p> </li> <li><code class="language-plaintext highlighter-rouge">msgsize</code> always set to <code class="language-plaintext highlighter-rouge">sizeof(msg.data)</code></li> </ul> </li> </ul> </li> <li> <p>Limits: There are limits on the number of message, size of total message in a queue, and size of message, total number of queues in a system</p> </li> </ul> </li> <li> <p>Semaphores: used as a counter to prevent two or more processes from accessing the shared resource at the same time</p> <ul> <li> <p>use <code class="language-plaintext highlighter-rouge">semwait</code> to decrease counter and <code class="language-plaintext highlighter-rouge">sempost</code> to increase won’t work well:</p> <ul> <li>the semaphore may not be shared by processes</li> <li>if kernel interrupt it, tt is not executed atomically <ul> <li>will cause inefficient CPU use if <code class="language-plaintext highlighter-rouge">semwait</code> wait on counter 0</li> </ul> </li> </ul> </li> <li> <p>System V semaphore:</p> <ul> <li><code class="language-plaintext highlighter-rouge">semget</code>get semaphore identifier but doesn’t initialize it, use <code class="language-plaintext highlighter-rouge">semctl</code> to set the counter</li> <li>Process or thread creates the semaphore also calls semctl to initialize it, and then use <code class="language-plaintext highlighter-rouge">sem_op</code> to set the sem_otime which is initialized as 0, so other process will wait until the sem_otime becomes non-zero (so they know it is initialized)</li> </ul> </li> <li> <p><code class="language-plaintext highlighter-rouge">semop</code>: operate on semaphore with struct <code class="language-plaintext highlighter-rouge">sembuf</code>,</p> <ul> <li> <p>each <code class="language-plaintext highlighter-rouge">sem_op</code> in <code class="language-plaintext highlighter-rouge">sembuf</code> can be positive, zero, or negative:</p> <ul> <li> <blockquote> <p>0 increment semaphore value</p> </blockquote> </li> <li> <p>&lt;0 decrease semaphore value</p> </li> <li>0 block until value get to 0</li> </ul> </li> <li> <p>all <code class="language-plaintext highlighter-rouge">semop</code> operation is atomic, and function doesn’t return until everything is done, blocking can be prevented with IPC_NOWAIT flag</p> </li> <li> <p>adjustment is stored for any increments or decrements, so op can be undone with IPC_UNDO flag</p> </li> </ul> </li> </ul> </li> <li> <p>Share Memory:</p> <ul> <li>System V shared memory: <ul> <li><code class="language-plaintext highlighter-rouge">shmget shmctl shmat shmdt</code>: used to get attach detach and control the shared memory, <code class="language-plaintext highlighter-rouge">shmget</code> will get you the identifier and is used in <code class="language-plaintext highlighter-rouge">shmctl</code>, but <code class="language-plaintext highlighter-rouge">shmat</code> gives you the pointer which should be passed to <code class="language-plaintext highlighter-rouge">shmdt</code></li> <li>Shared memory and Semaphore: You can not share memory between two processes without some form of semaphore control, can not assume the pointer is atomic. Procedures:</li> <li>The child assigned *p to local memory with the semaphore locked and then was free to use the local memory with the semaphore unlocked. <ul> <li>Similarly, the parent used a local variable in the for loop, locking the semaphore only to access the shared memory.</li> <li>Initially, the semaphore is locked (zero value), so the parent is free to initialize the shared memory to zero. Then it calls SimpleSemPost to get things moving. It’s OK if the child accesses the shared memory at that point. This version then can be run repeatedly since it initializes the segment each time it’s run.</li> <li>We remove the semaphore at the start of each run so that it will start with zero.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Signal: a notification that an event has occurred, it’s life cycle is that when the event it’s associated occurs and generates it until it is delivered and the action has been taken.</p> <ul> <li> <p>3 possible actions are: SIG_DFL for default, SIG_IGN for ignore, and user specified action, which is process-wide;</p> <ul> <li> <p><code class="language-plaintext highlighter-rouge">sigaction</code>: set signal action with struct <code class="language-plaintext highlighter-rouge">sigaction</code>, that can have SIG_DFL, SIG_IGN or a function pointer</p> </li> <li> <p><code class="language-plaintext highlighter-rouge">kill killpg pthread_kill abort riase</code> to generate signalst to pid:</p> <ul> <li> <blockquote> <p>0 whosse process is pid</p> </blockquote> </li> <li> <p>0 whose procexx group is the same as the sending-process</p> </li> <li> <p>&lt; -1 process-group id is absolute of pid</p> </li> <li>-1 all processes of sender has permission</li> </ul> </li> <li> <p>effect of <code class="language-plaintext highlighter-rouge">fork pthread_create exec</code> on signal:</p> <ol> <li>Signal actions: After a fork, the child inherits all signal actions. After an exec, signals set to SIG_DFL remain that way; signals set to SIG_IGN remain that way, except for SIGCHLD, which may be set to SIG_IGN or SIG_DFL, as the implementation chooses; caught signals are set to SIG_DFL. As all actions are process-wide, pthread_create has no effect.</li> <li>Signal mask: Inherited from the forking thread after a fork; stays the same as the execing thread after an exec; copied to the new thread from the creating thread after a pthread_create.</li> <li>Pending signals: Cleared after a fork; same as the execing thread after an exec; cleared after a pthread_create.</li> </ol> </li> </ul> </li> <li> <p>A signal mask is a collection of all pending/ blocking signals of this process</p> <ul> <li>Managing: <code class="language-plaintext highlighter-rouge">sigempset sigfillset sigaddset sigdelset sigismember</code> to test, set, or clear a sigmask bit. Start with <code class="language-plaintext highlighter-rouge">sigempset </code>or <code class="language-plaintext highlighter-rouge">sigfillset</code> and do other operation on the mask</li> <li>Set: there is only one sigmask at a time for one thread and it can be set by using <code class="language-plaintext highlighter-rouge">pthread_sigmask</code>, taking parameters <code class="language-plaintext highlighter-rouge">set</code> and <code class="language-plaintext highlighter-rouge">how</code>. SIG_BLOCK add the set, SIG_UNBLOCK remove the set, and SIG_SET set the mask to set; SIGKILL and SIGSTOP can not be blocked. If only one thread for a process, can use <code class="language-plaintext highlighter-rouge">sigprocmask</code> that use errno instead of returning error code.</li> </ul> </li> <li> <p>The delivery of a nonignored signal will cause the system call to be interrupted, if the action was to terminate, the interrupted system call is never resumed, if it is to stop the process, it will pick it up whenever it is left. only system calls that blocks – waiting for unpredictable result can be interrupted.</p> </li> <li> <p>Deprecated Signal System Call</p> <ul> <li>classic way to set sigaction <code class="language-plaintext highlighter-rouge">signal</code>: new action parameter looks like : <code class="language-plaintext highlighter-rouge">void (*act)(int)</code>, could be a pointer to a function taking an integer argument</li> <li>Upon delivery, the sigaction is reset to SIG_DFT, need to call <code class="language-plaintext highlighter-rouge">signal</code> again</li> <li>The delivered signal is not blocked, so the second arrival may terminate the process</li> </ul> </li> <li> <p>Global Jumps: normally a function returns by executing return statement but can be redirected by jmp:</p> <ul> <li><code class="language-plaintext highlighter-rouge">setjmp</code> with jmp_buf that hold a saved location info, return 0 if called directlym or return val set by long jmp. First, setjmp location with location info you need, and no matter how deep nested you are in a function, use <code class="language-plaintext highlighter-rouge">longjmp</code> to jum to arbitrary location</li> <li>To force sigmask beign restored, use <code class="language-plaintext highlighter-rouge">sigsetjmp</code> and <code class="language-plaintext highlighter-rouge">siglongjmp</code>, the sigmask restored is the one that is called when <code class="language-plaintext highlighter-rouge">sigsetjmp</code></li> <li>force the sigmask to be reset, use <code class="language-plaintext highlighter-rouge">_setjmp</code> and <code class="language-plaintext highlighter-rouge">_longjmp</code></li> </ul> </li> <li> <p>Clocks and Timers</p> <ul> <li><code class="language-plaintext highlighter-rouge">alarm</code>: every process has one alarm set for the system call, and SIGALARM is sent when the alarm goes off, a child inherits its parent’s alarm clock but the actual clock is not shared. The system call <code class="language-plaintext highlighter-rouge">alaram()</code> set the second given by sec and return the old value, if sec is 0 the alarm is turned off (eg: call a read, and set an alarm for 5 secs, if the read is longer than 5 sec, it will be blocked, but if it is shorter, remember to turn off the alarm, or it will block something else)</li> <li><code class="language-plaintext highlighter-rouge">sleep</code>: blocks a thread for specific time</li> </ul> </li> </ul> </li> </ul> <hr> <div class="row"> <div class="col-md-6"> <h5 style="display: inline;">Tags:</h5> <button class="btn btn-white btn-xs" type="button">UNIX</button> <button class="btn btn-white btn-xs" type="button">School</button> </div> <div class="col-md-6"> <div class="small text-right"> <div> </div> </div> </div> </div> <br> <div class="row"> <div class="col-lg-12"> <!-- donate --> <br> <!-- share --> <div class="a2a_kit a2a_kit_size_32 a2a_default_style"> <a class="a2a_dd" href="https://www.addtoany.com/share"></a> <a class="a2a_button_facebook"></a> <a class="a2a_button_twitter"></a> <a class="a2a_button_google_plus"></a> <a class="a2a_button_linkedin"></a> <a class="a2a_button_email"></a> <a class="a2a_button_wechat"></a> <a class="a2a_button_sina_weibo"></a> <a class="a2a_button_pocket"></a> </div> <script> var a2a_config = a2a_config || {}; a2a_config.color_main = "D7E5ED"; a2a_config.color_border = "AECADB"; a2a_config.color_link_text = "333333"; a2a_config.color_link_text_hover = "333333"; </script> <script async src="https://static.addtoany.com/menu/page.js"></script> <br> <!-- comment --> </div> </div> </div> </div> </div> </div> </div> <!-- Google analytics --> <!-- GrowingIO --> </body> </html>
